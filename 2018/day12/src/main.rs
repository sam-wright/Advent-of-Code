/*
                                       111   222
                       0  3 4  78      456   012
initial state: ........#..#.#..##......###...###.........
               000000001001010011000000111000111000000000

...## => #  0b00011
..#.. => #  0b00100
.#... => #  0b01000
.#.#. => #  0b01010
.#.## => #  0b01011
.##.. => #  0b01100
.#### => #  0b01111
#.#.# => #  0b10101
#.### => #  0b10111
##.#. => #  0b11010
##.## => #  0b11011
###.. => #  0b11100
###.# => #  0b11101
####. => #  0b11110
*/

/*
initial state: #...####.##..####..#.##....##...###.##.#..######..#..#..###..##.#.###.#####.##.#.#.#.##....#..#..#..
               1000111101100111100101100001100011101101001111110010010011100110101110111110110101010110000100100100

...## => .
...#. => #  0b00010
....# => .
###.# => #  0b11101
..... => .
..#.. => .
#.#.# => .
#..#. => .
#...# => .
##... => .
.#.#. => #  0b01010
.#..# => .
.###. => .
#..## => #  0b10011
..#.# => #  0b00101
.#### => #  0b01111
##..# => #  0b11001
##.#. => #  0b11010
.#... => #  0b01000
#.#.. => .
##### => .
###.. => #  0b11100
.##.# => .
#.##. => .
..### => .
.#.## => #  0b01011
..##. => #  0b00110
#.### => .
.##.. => #  0b01100
##.## => .
#.... => .
####. => #  0b11110

...#. => #  0b00010
###.# => #  0b11101
.#.#. => #  0b01010
#..## => #  0b10011
..#.# => #  0b00101
.#### => #  0b01111
##..# => #  0b11001
##.#. => #  0b11010
.#... => #  0b01000
###.. => #  0b11100
.#.## => #  0b01011
..##. => #  0b00110
.##.. => #  0b01100
####. => #  0b11110
*/

fn compute_index(rules: &[i32], state: &[i32], index: usize) -> i32 {
    if index < 3 || index > state.len() - 3 {
        return 0;
    }

    for r in rules {
        let value = state[index - 2] * 16
            + state[index - 1] * 8
            + state[index] * 4
            + state[index + 1] * 2
            + state[index + 2];

        if *r == value {
            return 1;
        }
    }

    0
}

fn print_state(state: &[i32]) {
    for s in state {
        if *s == 1 {
            print!("#");
        } else {
            print!(".");
        }
    }
}

fn score_state(state: &[i32], offset: i32) -> i32 {
    state.iter().enumerate().fold(0i32, |sum, (i, v)| {
        if *v == 1 {
            sum + (i as i32 - offset)
        } else {
            sum
        }
    })
}

fn main() {
    let _test_rules = vec![
        0b00011, 0b00100, 0b01000, 0b01010, 0b01011, 0b01100, 0b01111, 0b10101, 0b10111, 0b11010,
        0b11011, 0b11100, 0b11101, 0b11110,
    ];

    let _test_offset = 8;
    let mut _test_state = vec![
        0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];

    let rules = vec![
        0b00010, 0b11101, 0b01010, 0b10011, 0b00101, 0b01111, 0b11001, 0b11010, 0b01000, 0b11100,
        0b01011, 0b00110, 0b01100, 0b11110,
    ];

    let offset = 315;
    let mut zeros = vec![0i32; 100_000];
    let mut state = vec![
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1,
        1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1,
        1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1,
        0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
    ];
    state.append(&mut zeros);
    println!("\nIteration 0");
    print_state(&state);

    // Part-A
    for iteration in 1..=3500 {
        // Part-B
        //for iteration in 1..=50_000_000_000i128 {
        //println!("\nIteration {}", iteration);
        let mut new_state: Vec<i32> = state.clone();

        state
            .iter()
            .enumerate()
            .for_each(|(i, _v)| new_state[i] = compute_index(&rules, &state, i));
        //print_state(&new_state);
        state = new_state.clone();

        if iteration > 1000 {
            println!(
                "Iter: {}\tScore: {}",
                iteration,
                score_state(&state, offset)
            );
        }
    }

    print_state(&state);
    println!("Score: {}", score_state(&state, offset));

    println!("Part-B: {}", 80 * (50_000_000_000i128 - 3320) + 267080);
}
